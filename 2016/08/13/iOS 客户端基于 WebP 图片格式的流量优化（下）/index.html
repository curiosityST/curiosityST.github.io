<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 客户端基于 WebP 图片格式的流量优化（下） | Curiosity小鶸</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 客户端基于 WebP 图片格式的流量优化（下）</h1><a id="logo" href="/.">Curiosity小鶸</a><p class="description">人生何所求 致富和自由</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 客户端基于 WebP 图片格式的流量优化（下）</h1><div class="post-meta">Aug 13, 2016<span> | </span><span class="category"><a href="/categories/WebP/">WebP</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#一、SDWebImage缓存处理"><span class="toc-number">1.</span> <span class="toc-text">一、SDWebImage缓存处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、WebView图片缓存"><span class="toc-number">2.</span> <span class="toc-text">二、WebView图片缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三、中间层CacheManager处理"><span class="toc-number">3.</span> <span class="toc-text">三、中间层CacheManager处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四、其他情况的特别处理"><span class="toc-number">4.</span> <span class="toc-text">四、其他情况的特别处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>在 iOS 客户端基于 WebP 图片格式的流量优化（上）这篇文章中，已经介绍了WebP格式图片的下载使用，仅仅只有这样还远远不够，还需要对已经下载的图片数据进行缓存。</p>
<p>曾经有句名言『计算机世界有两大难题，第一是起名字，第二是写一个缓存』，鄙人不能同意更多。</p>
<a id="more"></a>
<p>在iOS上，重写一份图片缓存是不现实的，而直接修改SDWebImage框架也是不太好的。所以，在SDWebImage的基础上添加一个中间层CacheManager比较好。</p>
<p>我感觉，缓存的难度在于，如何准确命中。的确在开发的时候，一大半时间都是在测试缓存命中情况，测试本身就挺麻烦，需要在模拟器的沙盒里面看文件，同时断网测试，需要一些调试技巧，很多技巧并么有办法详尽表述出来，需要所谓的悟性去理解。</p>
<h3 id="一、SDWebImage缓存处理"><a href="#一、SDWebImage缓存处理" class="headerlink" title="一、SDWebImage缓存处理"></a>一、SDWebImage缓存处理</h3><p>这一部分，由于SD下载图片的方法中，url被替换，所以要看懂SD本身的代码，是什么时候给缓存一个确定的key。发现在</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)downloadImageWithURL:(<span class="built_in">NSURL</span> *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span>.class]) &#123;</div><div class="line">        url = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    url = [url qd_replaceToWebPURLWithScreenWidth];</div><div class="line">    ......</div></pre></td></tr></table></figure>
<p>方法中，确定了缓存的key值</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line"></div><div class="line">operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryDiskCacheForKey:key done:^(<span class="built_in">UIImage</span> *image, SDImageCacheType cacheType) &#123;</div></pre></td></tr></table></figure>
<p>这也就是之前，为什么要在这个方法的最前面把URL替换掉，这样，SD的key值已经是保护WebP格式的图片URL，这一部分的缓存都可以正常使用，不需要修改。</p>
<p>所以，难度还是在WebView的图片缓存中，因为之前虽然是用SD托管WebView中WebP图片的下载，然而WebView读缓存却不能自动从SDImageCache中读取。这样，需要用NSURLCache来接管WebView的图片缓存。</p>
<h3 id="二、WebView图片缓存"><a href="#二、WebView图片缓存" class="headerlink" title="二、WebView图片缓存"></a>二、WebView图片缓存</h3><p>关于WebView的缓存，系统提供了一个类，NSURLCache。这个类可以在所有的网络请求前查看缓存，并且决定是否缓存（注意：是所有请求）。具体的NSURLCache用法，动动勤劳的小手Google一下，很多文章可以参考。</p>
<p>我们自己的实现，直接上代码</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">QDURLCache</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  请求完成决定是否要将response进行存储</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)storeCachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse forRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="built_in">NSString</span>* ua = [request valueForHTTPHeaderField:<span class="string">@"User-Agent"</span>];</div><div class="line">    <span class="keyword">if</span> (!EmptyString(ua) &amp;&amp; [ua lf_containsSubString:<span class="string">@"AppleWebKit"</span>]) &#123;</div><div class="line">        <span class="comment">//判断本次请求是不是请求图片</span></div><div class="line">        <span class="keyword">if</span> ([[QDCacheManager defaultManager] isImageRequest:request]) &#123;</div><div class="line">            [[QDCacheManager defaultManager] storeImageResponse:cachedResponse forRequest:request];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//其他请求</span></div><div class="line">        <span class="keyword">if</span> ([[QDCacheManager defaultManager] shouldCacheExceptImageResponseForRequest:request]) &#123;</div><div class="line">            <span class="keyword">if</span> (![[QDCacheManager defaultManager] storeCachedResponse:cachedResponse forRequest:request]) &#123;</div><div class="line">                [<span class="keyword">super</span> storeCachedResponse:cachedResponse forRequest:request];</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> storeCachedResponse:cachedResponse forRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  每次发请求之前会调此方法,查看本地是否有缓存</div><div class="line"> */</div><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)cachedResponseForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="built_in">NSString</span>* ua = [request valueForHTTPHeaderField:<span class="string">@"User-Agent"</span>];</div><div class="line">    <span class="keyword">if</span> (!EmptyString(ua) &amp;&amp; [ua lf_containsSubString:<span class="string">@"AppleWebKit"</span>]) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([[QDCacheManager defaultManager] isImageRequest:request]) &#123; <span class="comment">//图片</span></div><div class="line">            <span class="comment">//从本地取图片</span></div><div class="line">            <span class="built_in">NSCachedURLResponse</span> *imageCacheResponse = [[QDCacheManager defaultManager] retrieveImageCacheResponseForRequest:request];</div><div class="line">            <span class="keyword">if</span> (imageCacheResponse) &#123;</div><div class="line">                <span class="keyword">return</span> imageCacheResponse;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> [<span class="keyword">super</span> cachedResponseForRequest:request];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([[QDCacheManager defaultManager] shouldCacheExceptImageResponseForRequest:request]) &#123; <span class="comment">//其它缓存的东西</span></div><div class="line">            <span class="comment">//判断本地自定义缓存目录是否存在</span></div><div class="line">            <span class="keyword">if</span> (![[QDCacheManager defaultManager] cacheAvaliableForRequest:request]) &#123;</div><div class="line">                <span class="built_in">NSCachedURLResponse</span> *response = [<span class="keyword">super</span> cachedResponseForRequest:request];</div><div class="line">                <span class="comment">//判断本地系统缓存目录是否存在</span></div><div class="line">                <span class="keyword">if</span> (response.data) &#123;</div><div class="line">                    <span class="built_in">BOOL</span> contentLengthValid = [((<span class="built_in">NSHTTPURLResponse</span> *)response.response) expectedContentLength] == [response.data length];</div><div class="line">                    <span class="comment">//判断是否是有效的文件</span></div><div class="line">                    <span class="keyword">if</span> (!contentLengthValid) &#123;</div><div class="line">                        <span class="keyword">return</span> response;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">//将系统缓存放到自定义的缓存目录中</span></div><div class="line">                    [[QDCacheManager defaultManager] storeCachedResponse:response forRequest:request];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">return</span> response;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//从本地缓存中取出对应的缓存</span></div><div class="line">            <span class="built_in">NSCachedURLResponse</span> *cachedResponse = [[QDCacheManager defaultManager] retrieveCachedResponseForRequest:request];</div><div class="line">            <span class="keyword">if</span> (cachedResponse) &#123;</div><div class="line">                <span class="keyword">return</span> cachedResponse;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> cachedResponseForRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeCachedResponseForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="keyword">if</span> ([[QDCacheManager defaultManager] cacheAvaliableForRequest:request]) &#123;</div><div class="line">        <span class="keyword">if</span> (![[QDCacheManager defaultManager] removeCachedResponseForRequest:request]) &#123;</div><div class="line">            LogI(<span class="string">@"Failed to remove local cache for request: %@"</span>, request.URL);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">super</span> removeCachedResponseForRequest:request];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这段代码并没有多么难以理解的地方，可以看出来，我们是新建了一个中间层QDCacheManager，来管理WebView的所有缓存。</p>
<p>而且，既然是全局影响，肯定要用UA包起来，防止误伤其他缓存。</p>
<p>这一段代码在调试的时候有个技巧，就是所有super方法的调用，在测试阶段，全部直接return，防止WebView自身的缓存干扰调试结果。这个方法在很多缓存处理的地方都需要注意，别的地方但凡出现了调用super方法的，调试中也一律是直接return的。</p>
<p>既然已经用QDCacheManager托管了缓存，URLCache类的任务就已经完成，储存Response由</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeCachedResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse forRequest:(<span class="built_in">NSURLRequest</span> *)request</div></pre></td></tr></table></figure>
<p>而下面：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)cachedResponseForRequest:(<span class="built_in">NSURLRequest</span> *)request</div></pre></td></tr></table></figure>
<p>在NSURLProtocol的startLoading方法执行之前，就调用了。很好理解，因为这个方法就是取缓存的方法，自然是先取，没有再去Loading。</p>
<p>这里的逻辑，必须通过大量调试，反复验证，不能简单套用别人的结论，甚至官方文档也要怀疑的态度来看。因为，很多第三方框架，会影响NSURLCache类，我在调试时，就发现，JSPatch，React Native还有我们的一个放劫持服务，都有可能影响这个类中方法的调用。</p>
<p>下面就转入我们自己的缓存管理方法中去，由于现在关注的是WebP图片问题，所以，其他缓存处理就不再展开。</p>
<h3 id="三、中间层CacheManager处理"><a href="#三、中间层CacheManager处理" class="headerlink" title="三、中间层CacheManager处理"></a>三、中间层CacheManager处理</h3><p>关于这个中间层，主要处理的实际就是缓存key的问题，因为请求的时候，request里的URL仍然是没有替换WebP的，所以，需要先用之前qd_defultWebPURLCacheKey方法来获取真实图片缓存key值。<br>思路的关键就是换key，再取cache，代码本身就只能靠功底了。</p>
<p>直接上代码，没什么好解释的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isImageRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    <span class="keyword">if</span> (![request.URL.absoluteString qd_isQdailyHost]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSArray</span> *extensions = @[<span class="string">@".jpg"</span>, <span class="string">@".jpeg"</span>, <span class="string">@".png"</span>, <span class="string">@".gif"</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *extension <span class="keyword">in</span> extensions) &#123;</div><div class="line">        <span class="keyword">if</span> ([request.URL.absoluteString.lowercaseString lf_containsSubString:extension])&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)storeImageResponse:(<span class="built_in">NSCachedURLResponse</span> *)cachedResponse forRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *key = [request.URL qd_defultWebPURLCacheKey];</div><div class="line">    <span class="keyword">if</span> ([_imageCache imageFromDiskCacheForKey:key]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">dispatch_async</span>([_imageCache currentIOQueue], ^&#123;</div><div class="line">        <span class="comment">// 硬盘缓存直接存data，webp格式；内存缓存为UIImage，可以直接使用</span></div><div class="line">        [_imageCache storeImageDataToDisk:cachedResponse.data forKey:key];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSCachedURLResponse</span> *)retrieveImageCacheResponseForRequest:(<span class="built_in">NSURLRequest</span> *)request &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *key = [request.URL qd_defultWebPURLCacheKey];</div><div class="line">    <span class="built_in">NSString</span> *defaultPath = [_imageCache defaultCachePathForKey:key];</div><div class="line">    </div><div class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> ([_imageCache imageFromMemoryCacheForKey:key]) &#123;</div><div class="line">        <span class="built_in">UIImage</span> * image = [_imageCache imageFromMemoryCacheForKey:key];</div><div class="line">        <span class="keyword">if</span> ([key lf_containsSubString:<span class="string">@".png"</span>]) &#123;</div><div class="line">            data = <span class="built_in">UIImagePNGRepresentation</span>(image);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            data = <span class="built_in">UIImageJPEGRepresentation</span>(image, <span class="number">1.0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (data &amp;&amp;  data.length != <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:request.URL</div><div class="line">                                                            MIMEType:[request.URL.absoluteString qd_MIMEType]</div><div class="line">                                               expectedContentLength:data.length</div><div class="line">                                                    textEncodingName:<span class="literal">nil</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    data = [<span class="built_in">NSData</span> dataWithContentsOfFile:defaultPath];</div><div class="line">    <span class="keyword">if</span> (data == <span class="literal">nil</span>) &#123;</div><div class="line">        data = [<span class="built_in">NSData</span> dataWithContentsOfFile:[defaultPath stringByDeletingPathExtension]];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (data == <span class="literal">nil</span> || data.length == <span class="number">0</span>) &#123;</div><div class="line">        [_imageCache removeImageForKey:key fromDisk:<span class="literal">YES</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSURLResponse</span> *response = [[<span class="built_in">NSURLResponse</span> alloc] initWithURL:request.URL</div><div class="line">                                                        MIMEType:[request.URL.absoluteString qd_MIMEType]</div><div class="line">                                           expectedContentLength:data.length</div><div class="line">                                                textEncodingName:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [[<span class="built_in">NSCachedURLResponse</span> alloc] initWithResponse:response data:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中currentIOQueue方法，是修改了一下SDImageCache，暴露这个IOQueue，原来的框架是没有这个方法的。</p>
<p>至于为什么图片硬盘缓存直接用data，因为这里考虑是性能问题，取缓存的时候，返回的NSURLResponse所携带的，肯定还是NSData，如果当时存了UIImage格式，内部一样是转码成了NSData，而取的时候，还是按UIImage格式取，再转成NSData返回，相当于多了两次转码。</p>
<p>内存缓存却没有这个问题，因为SD的内存缓存，用的NSCache，存的就是UIImage对象，可以直接取出来用。</p>
<p>这里其实仍然并没有什么好讲的，还是基本的逻辑问题，需要比较严谨地处理。</p>
<h3 id="四、其他情况的特别处理"><a href="#四、其他情况的特别处理" class="headerlink" title="四、其他情况的特别处理"></a>四、其他情况的特别处理</h3><p>我们的app是实现了wifi预加载了，然而这一部分也需要与上面完成的缓存体系通用，不然，wifi预加载的意义就不大。</p>
<p>首先，我们的wifi预加载，是自己写了一个URLSession，所以在下载前替换URL就可以</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *urlString <span class="keyword">in</span> resourcesArray) &#123;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> ([urlString isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">	</div><div class="line">	<span class="built_in">NSURL</span> *theURL = [<span class="built_in">NSURL</span> URLWithString:urlString];</div><div class="line">	</div><div class="line">	<span class="keyword">if</span> ([[QDCacheManager defaultManager] isImageRequest:[<span class="built_in">NSURLRequest</span> requestWithURL:theURL]]) &#123;</div><div class="line">		theURL = [theURL qd_replaceToWebPURLWithScreenWidth];</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>(![[QDCacheManager defaultManager] cacheAvaliableForURL:theURL] &amp;&amp; ![[SDImageCache sharedImageCache] diskImageExistsWithKey:theURL.absoluteString]) &#123;</div><div class="line">		__<span class="keyword">weak</span> QDPrefetcher* weakSelf = <span class="keyword">self</span>;</div><div class="line">		[<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;</div><div class="line">                           </div><div class="line">                     ......</div></pre></td></tr></table></figure>
<p>部分代码如上，关键也在于替换URL时机和判断缓存情况。而下载之后的文件存到哪，是需要处理的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><div class="line"><span class="meta">#pragma mark NSURLSession Delegate</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location &#123;</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *destinationPath = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> ([[QDCacheManager defaultManager] isImageRequest:downloadTask.originalRequest]) &#123;</div><div class="line">        <span class="built_in">NSString</span> *key = downloadTask.originalRequest.URL.absoluteString;</div><div class="line">        destinationPath = [[SDImageCache sharedImageCache] defaultCachePathForKey:key];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        destinationPath = [[QDCacheManager defaultManager] localCachedWebContentPathWithRequest:downloadTask.originalRequest];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:destinationPath]) &#123;</div><div class="line">        [fileManager removeItemAtPath:destinationPath error:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [fileManager copyItemAtPath:location.path toPath:destinationPath error:&amp;error];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我是在finish的方法里面，把图片下载的目录直接copy给SDImageCache的缓存目录。这样，SD的缓存里面就有了这些WebP格式的NSData，与之前的代码逻辑统一，格式统一。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先有了一个心得，看上去很复杂的功能，可能实际代码并不需要自己写多少，学会在前人的基础上再加工，比如我们现在这套WebP适配，底层仍然是SDWebImage的基本逻辑，我们只不过在上层，加一些判断和处理，来适应业务层丰富的功能。</p>
<p>而且，代码是一步步写出来的，提前设想的方案，并不一定能实现，先实现功能，再优化架构，才是正确的方向。当时在WebURLProtocol里面，绕了很大的弯子，甚至还涉及到了多线程问题，不小心发现了iOS8，9，10三个版本的内部实现都在变化，绕开了一个个坑，才逐步清晰了整个逻辑。</p>
<p>总结整个方案的逻辑，其实比较清晰：</p>
<ul>
<li>首先确定是不是需要被替换的图片URL，然后所有的替换都采用统一方法，与之配套的key，也用这套方法处理得到他被替换后的URL，保证命中。</li>
<li>然后，无论Native请求还是WebView请求，都用SD托管，避免两套处理逻辑造成的种种不确定性；</li>
<li>而WebView的缓存，通过一个中间层处理，再交给SDImageCache，使之与Native请求的数据统一，让两种图片请求公用一套缓存，进一步重用。</li>
</ul>
<p>思路大致如此，其他的问题，就需要靠代码能力了。</p>
<hr>
<p>一口气写完，有不完善的地方，可能日后会有部分修改。肯定有很多大神的代码写得更好，或者写了更好的方案，也希望多多交流，共同进步。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://curiosityst.github.io/2016/08/13/iOS 客户端基于 WebP 图片格式的流量优化（下）/" data-id="cj1atpk740002vfs6abjyffpk" class="article-share-link">分享到</a><div class="tags"><a href="/tags/iOS实际应用/">iOS实际应用</a></div><div class="post-nav"><a href="/2016/08/11/iOS 客户端基于 WebP 图片格式的流量优化（上）/" class="pre">iOS 客户端基于 WebP 图片格式的流量优化（上）</a><a href="/2016/12/20/从@property说起（一）开题篇/" class="next">从@property说起（一）开题篇</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://curiosityst.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/24/针尖上带着脚镣跳舞的widget/">针尖上带着脚镣跳舞的widget</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/14/从-property说起（四）深入成员变量/">从@property说起（四）深入成员变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/从-property说起（三）atomic与多线程锁/">从@property说起（三）atomic与多线程锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/21/从-property说起（二）当我们写下-property-nonatomic-weak-id-obj时，我们究竟写了什么/">从@property说起（二）weak关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/从@property说起（一）开题篇/">从@property说起（一）开题篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/13/iOS 客户端基于 WebP 图片格式的流量优化（下）/">iOS 客户端基于 WebP 图片格式的流量优化（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/11/iOS 客户端基于 WebP 图片格式的流量优化（上）/">iOS 客户端基于 WebP 图片格式的流量优化（上）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/WebP/">WebP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Widget/">Widget</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/从-property说起/">从@property说起</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS实际应用/" style="font-size: 15px;">iOS实际应用</a> <a href="/tags/OC基础/" style="font-size: 15px;">OC基础</a> <a href="/tags/iOS10-Widget/" style="font-size: 15px;">iOS10 Widget</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Curiosity小鶸.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>