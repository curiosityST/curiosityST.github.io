<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 客户端基于 WebP 图片格式的流量优化（下） | Curiosity小鶸</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 客户端基于 WebP 图片格式的流量优化（下）</h1><a id="logo" href="/.">Curiosity小鶸</a><p class="description">人生何所求 致富和自由</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 客户端基于 WebP 图片格式的流量优化（下）</h1><div class="post-meta">Aug 13, 2016<span> | </span><span class="category"><a href="/categories/proj实践/">proj实践</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>在 iOS 客户端基于 WebP 图片格式的流量优化（上）这篇文章中，已经介绍了WebP格式图片的下载使用，仅仅只有这样还远远不够，还需要对已经下载的图片数据进行缓存。</p>
<p>曾经有句名言『计算机世界有两大难题，第一是起名字，第二是写一个缓存』，鄙人不能同意更多。</p>
<p>在iOS上，重写一份图片缓存是不现实的，而直接修改SDWebImage框架也是不太好的。所以，在SDWebImage的基础上添加一个中间层CacheManager比较好。</p>
<p>我感觉，缓存的难度在于，如何准确命中。的确在开发的时候，一大半时间都是在测试缓存命中情况，测试本身就挺麻烦，需要在模拟器的沙盒里面看文件，同时断网测试，需要一些调试技巧，很多技巧并么有办法详尽表述出来，需要所谓的悟性去理解。</p>
<h3 id="一、SDWebImage缓存处理"><a href="#一、SDWebImage缓存处理" class="headerlink" title="一、SDWebImage缓存处理"></a>一、SDWebImage缓存处理</h3><p>这一部分，由于SD下载图片的方法中，url被替换，所以要看懂SD本身的代码，是什么时候给缓存一个确定的key。发现在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (id &lt;SDWebImageOperation&gt;)downloadImageWithURL:(NSURL *)url</div><div class="line">                                         options:(SDWebImageOptions)options</div><div class="line">                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock &#123;</div><div class="line"></div><div class="line">    if ([url isKindOfClass:NSString.class]) &#123;</div><div class="line">        url = [NSURL URLWithString:(NSString *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (![url isKindOfClass:NSURL.class]) &#123;</div><div class="line">        url = nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    url = [url qd_replaceToWebPURLWithScreenWidth];</div><div class="line">    ......</div></pre></td></tr></table></figure>
<p>方法中，确定了缓存的key值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *key = [self cacheKeyForURL:url];</div><div class="line"></div><div class="line">operation.cacheOperation = [self.imageCache queryDiskCacheForKey:key done:^(UIImage *image, SDImageCacheType cacheType) &#123;</div></pre></td></tr></table></figure>
<p>这也就是之前，为什么要在这个方法的最前面把URL替换掉，这样，SD的key值已经是保护WebP格式的图片URL，这一部分的缓存都可以正常使用，不需要修改。</p>
<p>所以，难度还是在WebView的图片缓存中，因为之前虽然是用SD托管WebView中WebP图片的下载，然而WebView读缓存却不能自动从SDImageCache中读取。这样，需要用NSURLCache来接管WebView的图片缓存。</p>
<h3 id="二、WebView图片缓存"><a href="#二、WebView图片缓存" class="headerlink" title="二、WebView图片缓存"></a>二、WebView图片缓存</h3><p>关于WebView的缓存，系统提供了一个类，NSURLCache。这个类可以在所有的网络请求前查看缓存，并且决定是否缓存（注意：是所有请求）。具体的NSURLCache用法，动动勤劳的小手Google一下，很多文章可以参考。</p>
<p>我们自己的实现，直接上代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></td><td class="code"><pre><div class="line">@implementation QDURLCache</div><div class="line"></div><div class="line">/**</div><div class="line"> *  请求完成决定是否要将response进行存储</div><div class="line"> */</div><div class="line">- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request &#123;</div><div class="line">    NSString* ua = [request valueForHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">    if (!EmptyString(ua) &amp;&amp; [ua lf_containsSubString:@&quot;AppleWebKit&quot;]) &#123;</div><div class="line">        //判断本次请求是不是请求图片</div><div class="line">        if ([[QDCacheManager defaultManager] isImageRequest:request]) &#123;</div><div class="line">            [[QDCacheManager defaultManager] storeImageResponse:cachedResponse forRequest:request];</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //其他请求</div><div class="line">        if ([[QDCacheManager defaultManager] shouldCacheExceptImageResponseForRequest:request]) &#123;</div><div class="line">            if (![[QDCacheManager defaultManager] storeCachedResponse:cachedResponse forRequest:request]) &#123;</div><div class="line">                [super storeCachedResponse:cachedResponse forRequest:request];</div><div class="line">                return;</div><div class="line">            &#125; else &#123;</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [super storeCachedResponse:cachedResponse forRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  每次发请求之前会调此方法,查看本地是否有缓存</div><div class="line"> */</div><div class="line">- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request &#123;</div><div class="line">    NSString* ua = [request valueForHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">    if (!EmptyString(ua) &amp;&amp; [ua lf_containsSubString:@&quot;AppleWebKit&quot;]) &#123;</div><div class="line">        </div><div class="line">        if ([[QDCacheManager defaultManager] isImageRequest:request]) &#123; //图片</div><div class="line">            //从本地取图片</div><div class="line">            NSCachedURLResponse *imageCacheResponse = [[QDCacheManager defaultManager] retrieveImageCacheResponseForRequest:request];</div><div class="line">            if (imageCacheResponse) &#123;</div><div class="line">                return imageCacheResponse;</div><div class="line">            &#125; else &#123;</div><div class="line">                return [super cachedResponseForRequest:request];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if ([[QDCacheManager defaultManager] shouldCacheExceptImageResponseForRequest:request]) &#123; //其它缓存的东西</div><div class="line">            //判断本地自定义缓存目录是否存在</div><div class="line">            if (![[QDCacheManager defaultManager] cacheAvaliableForRequest:request]) &#123;</div><div class="line">                NSCachedURLResponse *response = [super cachedResponseForRequest:request];</div><div class="line">                //判断本地系统缓存目录是否存在</div><div class="line">                if (response.data) &#123;</div><div class="line">                    BOOL contentLengthValid = [((NSHTTPURLResponse *)response.response) expectedContentLength] == [response.data length];</div><div class="line">                    //判断是否是有效的文件</div><div class="line">                    if (!contentLengthValid) &#123;</div><div class="line">                        return response;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    //将系统缓存放到自定义的缓存目录中</div><div class="line">                    [[QDCacheManager defaultManager] storeCachedResponse:response forRequest:request];</div><div class="line">                &#125; else &#123;</div><div class="line">                &#125;</div><div class="line">                return response;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            //从本地缓存中取出对应的缓存</div><div class="line">            NSCachedURLResponse *cachedResponse = [[QDCacheManager defaultManager] retrieveCachedResponseForRequest:request];</div><div class="line">            if (cachedResponse) &#123;</div><div class="line">                return cachedResponse;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return [super cachedResponseForRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeCachedResponseForRequest:(NSURLRequest *)request &#123;</div><div class="line">    if ([[QDCacheManager defaultManager] cacheAvaliableForRequest:request]) &#123;</div><div class="line">        if (![[QDCacheManager defaultManager] removeCachedResponseForRequest:request]) &#123;</div><div class="line">            LogI(@&quot;Failed to remove local cache for request: %@&quot;, request.URL);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        [super removeCachedResponseForRequest:request];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>这段代码并没有多么难以理解的地方，可以看出来，我们是新建了一个中间层QDCacheManager，来管理WebView的所有缓存。</p>
<p>而且，既然是全局影响，肯定要用UA包起来，防止误伤其他缓存。</p>
<p>这一段代码在调试的时候有个技巧，就是所有super方法的调用，在测试阶段，全部直接return，防止WebView自身的缓存干扰调试结果。这个方法在很多缓存处理的地方都需要注意，别的地方但凡出现了调用super方法的，调试中也一律是直接return的。</p>
<p>既然已经用QDCacheManager托管了缓存，URLCache类的任务就已经完成，储存Response由</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request</div></pre></td></tr></table></figure>
<p>而下面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request</div></pre></td></tr></table></figure>
<p>在NSURLProtocol的startLoading方法执行之前，就调用了。很好理解，因为这个方法就是取缓存的方法，自然是先取，没有再去Loading。</p>
<p>这里的逻辑，必须通过大量调试，反复验证，不能简单套用别人的结论，甚至官方文档也要怀疑的态度来看。因为，很多第三方框架，会影响NSURLCache类，我在调试时，就发现，JSPatch，React Native还有我们的一个放劫持服务，都有可能影响这个类中方法的调用。</p>
<p>下面就转入我们自己的缓存管理方法中去，由于现在关注的是WebP图片问题，所以，其他缓存处理就不再展开。</p>
<h3 id="三、中间层CacheManager处理"><a href="#三、中间层CacheManager处理" class="headerlink" title="三、中间层CacheManager处理"></a>三、中间层CacheManager处理</h3><p>关于这个中间层，主要处理的实际就是缓存key的问题，因为请求的时候，request里的URL仍然是没有替换WebP的，所以，需要先用之前qd_defultWebPURLCacheKey方法来获取真实图片缓存key值。<br>思路的关键就是换key，再取cache，代码本身就只能靠功底了。</p>
<p>直接上代码，没什么好解释的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">- (BOOL)isImageRequest:(NSURLRequest *)request &#123;</div><div class="line">    if (![request.URL.absoluteString qd_isQdailyHost]) &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">    NSArray *extensions = @[@&quot;.jpg&quot;, @&quot;.jpeg&quot;, @&quot;.png&quot;, @&quot;.gif&quot;];</div><div class="line">    for (NSString *extension in extensions) &#123;</div><div class="line">        if ([request.URL.absoluteString.lowercaseString lf_containsSubString:extension])&#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)storeImageResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request &#123;</div><div class="line">    </div><div class="line">    NSString *key = [request.URL qd_defultWebPURLCacheKey];</div><div class="line">    if ([_imageCache imageFromDiskCacheForKey:key]) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    dispatch_async([_imageCache currentIOQueue], ^&#123;</div><div class="line">        // 硬盘缓存直接存data，webp格式；内存缓存为UIImage，可以直接使用</div><div class="line">        [_imageCache storeImageDataToDisk:cachedResponse.data forKey:key];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSCachedURLResponse *)retrieveImageCacheResponseForRequest:(NSURLRequest *)request &#123;</div><div class="line">    </div><div class="line">    NSString *key = [request.URL qd_defultWebPURLCacheKey];</div><div class="line">    NSString *defaultPath = [_imageCache defaultCachePathForKey:key];</div><div class="line">    </div><div class="line">    NSData *data = nil;</div><div class="line">    if ([_imageCache imageFromMemoryCacheForKey:key]) &#123;</div><div class="line">        UIImage * image = [_imageCache imageFromMemoryCacheForKey:key];</div><div class="line">        if ([key lf_containsSubString:@&quot;.png&quot;]) &#123;</div><div class="line">            data = UIImagePNGRepresentation(image);</div><div class="line">        &#125; else &#123;</div><div class="line">            data = UIImageJPEGRepresentation(image, 1.0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if (data &amp;&amp;  data.length != 0) &#123;</div><div class="line">        NSURLResponse *response = [[NSURLResponse alloc] initWithURL:request.URL</div><div class="line">                                                            MIMEType:[request.URL.absoluteString qd_MIMEType]</div><div class="line">                                               expectedContentLength:data.length</div><div class="line">                                                    textEncodingName:nil];</div><div class="line">        </div><div class="line">        return [[NSCachedURLResponse alloc] initWithResponse:response data:data];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    data = [NSData dataWithContentsOfFile:defaultPath];</div><div class="line">    if (data == nil) &#123;</div><div class="line">        data = [NSData dataWithContentsOfFile:[defaultPath stringByDeletingPathExtension]];</div><div class="line">    &#125;</div><div class="line">    if (data == nil || data.length == 0) &#123;</div><div class="line">        [_imageCache removeImageForKey:key fromDisk:YES];</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    NSURLResponse *response = [[NSURLResponse alloc] initWithURL:request.URL</div><div class="line">                                                        MIMEType:[request.URL.absoluteString qd_MIMEType]</div><div class="line">                                           expectedContentLength:data.length</div><div class="line">                                                textEncodingName:nil];</div><div class="line">    </div><div class="line">    return [[NSCachedURLResponse alloc] initWithResponse:response data:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中currentIOQueue方法，是修改了一下SDImageCache，暴露这个IOQueue，原来的框架是没有这个方法的。</p>
<p>至于为什么图片硬盘缓存直接用data，因为这里考虑是性能问题，取缓存的时候，返回的NSURLResponse所携带的，肯定还是NSData，如果当时存了UIImage格式，内部一样是转码成了NSData，而取的时候，还是按UIImage格式取，再转成NSData返回，相当于多了两次转码。</p>
<p>内存缓存却没有这个问题，因为SD的内存缓存，用的NSCache，存的就是UIImage对象，可以直接取出来用。</p>
<p>这里其实仍然并没有什么好讲的，还是基本的逻辑问题，需要比较严谨地处理。</p>
<h3 id="四、其他情况的特别处理"><a href="#四、其他情况的特别处理" class="headerlink" title="四、其他情况的特别处理"></a>四、其他情况的特别处理</h3><p>我们的app是实现了wifi预加载了，然而这一部分也需要与上面完成的缓存体系通用，不然，wifi预加载的意义就不大。</p>
<p>首先，我们的wifi预加载，是自己写了一个URLSession，所以在下载前替换URL就可以</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">for (NSString *urlString in resourcesArray) &#123;</div><div class="line">                   if ([urlString isKindOfClass:[NSString class]]) &#123;</div><div class="line">                       </div><div class="line">                       NSURL *theURL = [NSURL URLWithString:urlString];</div><div class="line">                       if ([[QDCacheManager defaultManager] isImageRequest:[NSURLRequest requestWithURL:theURL]]) &#123;</div><div class="line">                           theURL = [theURL qd_replaceToWebPURLWithScreenWidth];</div><div class="line">                       &#125;</div><div class="line">                       if(![[QDCacheManager defaultManager] cacheAvaliableForURL:theURL] &amp;&amp; ![[SDImageCache sharedImageCache] diskImageExistsWithKey:theURL.absoluteString]) &#123;</div><div class="line">                           __weak QDPrefetcher* weakSelf = self;</div><div class="line">                           [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</div><div class="line">                           </div><div class="line">                     ......</div></pre></td></tr></table></figure>
<p>部分代码如上，关键也在于替换URL时机和判断缓存情况。而下载之后的文件存到哪，是需要处理的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#pragma mark NSURLSession Delegate</div><div class="line"></div><div class="line">- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location &#123;</div><div class="line">    NSError *error = nil;</div><div class="line">    NSFileManager *fileManager = [NSFileManager defaultManager];</div><div class="line"></div><div class="line">    NSString *destinationPath = nil;</div><div class="line">    if ([[QDCacheManager defaultManager] isImageRequest:downloadTask.originalRequest]) &#123;</div><div class="line">        NSString *key = downloadTask.originalRequest.URL.absoluteString;</div><div class="line">        destinationPath = [[SDImageCache sharedImageCache] defaultCachePathForKey:key];</div><div class="line">    &#125; else &#123;</div><div class="line">        destinationPath = [[QDCacheManager defaultManager] localCachedWebContentPathWithRequest:downloadTask.originalRequest];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    if ([fileManager fileExistsAtPath:destinationPath]) &#123;</div><div class="line">        [fileManager removeItemAtPath:destinationPath error:nil];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [fileManager copyItemAtPath:location.path toPath:destinationPath error:&amp;error];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我是在finish的方法里面，把图片下载的目录直接copy给SDImageCache的缓存目录。这样，SD的缓存里面就有了这些WebP格式的NSData，与之前的代码逻辑统一，格式统一。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>首先有了一个心得，看上去很复杂的功能，可能实际代码并不需要自己写多少，学会在前人的基础上再加工，比如我们现在这套WebP适配，底层仍然是SDWebImage的基本逻辑，我们只不过在上层，加一些判断和处理，来适应业务层丰富的功能。</p>
<p>而且，代码是一步步写出来的，提前设想的方案，并不一定能实现，先实现功能，再优化架构，才是正确的方向。当时在WebURLProtocol里面，绕了很大的弯子，甚至还涉及到了多线程问题，不小心发现了iOS8，9，10三个版本的内部实现都在变化，绕开了一个个坑，才逐步清晰了整个逻辑。</p>
<p>总结整个方案的逻辑，其实比较清晰：</p>
<ul>
<li>首先确定是不是需要被替换的图片URL，然后所有的替换都采用统一方法，与之配套的key，也用这套方法处理得到他被替换后的URL，保证命中。</li>
<li>然后，无论Native请求还是WebView请求，都用SD托管，避免两套处理逻辑造成的种种不确定性；</li>
<li>而WebView的缓存，通过一个中间层处理，再交给SDImageCache，使之与Native请求的数据统一，让两种图片请求公用一套缓存，进一步重用。</li>
</ul>
<p>思路大致如此，其他的问题，就需要靠代码能力了。</p>
<hr>
<p>一口气写完，有不完善的地方，可能日后会有部分修改。肯定有很多大神的代码写得更好，或者写了更好的方案，也希望多多交流，共同进步。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://curiosityst.github.io/2016/08/13/iOS 客户端基于 WebP 图片格式的流量优化（下）/" data-id="cj1ag3rey0002bbs6jloxyux2" class="article-share-link">分享到</a><div class="tags"><a href="/tags/iOS实际应用/">iOS实际应用</a></div><div class="post-nav"><a href="/2016/08/11/iOS 客户端基于 WebP 图片格式的流量优化（上）/" class="pre">iOS 客户端基于 WebP 图片格式的流量优化（上）</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://curiosityst.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/08/13/iOS 客户端基于 WebP 图片格式的流量优化（下）/">iOS 客户端基于 WebP 图片格式的流量优化（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/11/iOS 客户端基于 WebP 图片格式的流量优化（上）/">iOS 客户端基于 WebP 图片格式的流量优化（上）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/proj实践/">proj实践</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS实际应用/" style="font-size: 15px;">iOS实际应用</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Curiosity小鶸.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>