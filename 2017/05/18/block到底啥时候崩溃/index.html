<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>block到底啥时候崩溃 | Me</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/6.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">block到底啥时候崩溃</h1><a id="logo" href="/.">Me</a><p class="description">人生何所求 致富和自由</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">block到底啥时候崩溃</h1><div class="post-meta">May 18, 2017<span> | </span><span class="category"><a href="/categories/block/">block</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#block的数据结构"><span class="toc-text">block的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#全局block"><span class="toc-text">全局block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈block"><span class="toc-text">栈block</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#堆block"><span class="toc-text">堆block</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARC下的block"><span class="toc-text">ARC下的block</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局block-1"><span class="toc-text">全局block</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆block和栈block"><span class="toc-text">堆block和栈block</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结论"><span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-text">Reference</span></a></li></ol></div></div><div class="post-content"><p>block可以说是OC一项非常好用的功能。block的本质，实际上是『带有自动变量值的匿名函数』。但是在block的使用上，有各种江湖传说，说在某某情况下，block的使用是不安全的，会造成崩溃。于是也有很多面试题喜欢考察block。但是，实际的block的不安全使用，貌似除了循环引用，也没遇到过什么情况啊？我敢说，block在现如今的iOS开发中，99%的崩溃都是因为你没有给block判空。而其他问题，都是因为循环引用。那么block到底啥时候不安全呢？</p>
<p>其实关于block，我们不用那么害怕。</p>
<h2 id="block的数据结构"><a href="#block的数据结构" class="headerlink" title="block的数据结构"></a>block的数据结构</h2><p>首先，block的数据结构其实可以通过查看源码来获得。关于block的数据结构和runtime是开源的，可以在<a href="https://llvm.org/svn/llvm-project/compiler-rt/trunk/BlocksRuntime/" target="_blank" rel="external">llvm项目</a>看到，或者下载苹果的<a href="http://www.opensource.apple.com/tarballs/libclosure/" target="_blank" rel="external">libclosure</a>库的源码来看。苹果也提供了<a href="http://opensource.apple.com/source/libclosure/libclosure-63/" target="_blank" rel="external">在线的代码查看</a>方式，其中包含了很多示例和文档说明。</p>
<p>所以，block真正的结构，就是这个样子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">struct</span> Block_descriptor_1 &#123;</div><div class="line">    <span class="keyword">uintptr_t</span> reserved;</div><div class="line">    <span class="keyword">uintptr_t</span> size;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="keyword">struct</span> Block_layout &#123;</div><div class="line">    <span class="keyword">void</span> *isa;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int32_t</span> flags; <span class="comment">// contains ref count</span></div><div class="line">    <span class="keyword">int32_t</span> reserved; </div><div class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...);</div><div class="line">    <span class="keyword">struct</span> Block_descriptor_1 *descriptor;</div><div class="line">    <span class="comment">// imported variables</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在objc中，根据对象的定义，凡是首地址是*isa的结构体指针，都可以认为是对象(id)。这样在objc中，block实际上就算是对象。</p>
<p>那么既然block是个对象，那么block就应该有Class，那么block的Class是什么呢？</p>
<p>在block runtime中，定义了6种类：</p>
<blockquote>
<p>_NSConcreteStackBlock         栈上创建的block</p>
<p>_NSConcreteMallocBlock      堆上创建的block</p>
<p>_NSConcreteGlobalBlock       作为全局变量的block</p>
<p>_NSConcreteWeakBlockVariable</p>
<p>_NSConcreteAutoBlock</p>
<p>_NSConcreteFinalizingBlock</p>
</blockquote>
<p>其中我们能接触到的主要是前3种，后三种用于GC不做讨论。</p>
<h3 id="全局block"><a href="#全局block" class="headerlink" title="全局block"></a>全局block</h3><p>其实，这三种block类型的情况非常好理解。</p>
<p>首先我们要明确，在编译完成后，block内部的代码将会提取出来，成为一个单独的C函数。创建block时，实际就是在方法中声明一个struct，并且初始化该struct的成员。而执行block时，就是调用那个单独的C函数，并把该struct指针传递过去。<strong>block的的实际作用效果，相当于C语言中的匿名函数</strong>。</p>
<p>于是，就可以理解<code>_NSConcreteGlobalBlock</code>的使用了。因为全局block是当一个block内部没有捕获任何外部变量时，就会是一个全局block类型。此时，这个block与一个函数无异。所以，那么它就应该有和函数一样的静态特性。而且，我们在调用block的时候，其实和普通C函数的调用很相似，都是名称加括号：<code>block()</code>。</p>
<p>那么有函数一样静态特性的block，显然不需要再取考虑他的生命周期。</p>
<h3 id="栈block"><a href="#栈block" class="headerlink" title="栈block"></a>栈block</h3><p>这个类型的block，是在编译器发现block内部引用了外部变量后，会生成的block类型。</p>
<p>在block内部有引用外部变量时，当struct第一次被创建时，它是存在于该函数的栈帧上的，其Class是固定的_NSConcreteStackBlock。其捕获的变量是会赋值到结构体的成员上，所以当block初始化完成后，捕获到的变量不能更改。</p>
<p>当函数返回时，函数的栈帧被销毁，这个block的内存也会被清除。所以在函数结束后仍然需要这个block时，就必须用Block_copy()方法将它拷贝到堆上。这个方法的核心动作很简单：申请内存，将栈数据复制过去，将Class改一下，最后向捕获到的对象发送retain，增加block的引用计数。详细代码可以直接<a href="http://opensource.apple.com/source/libclosure/libclosure-63/runtime.c" target="_blank" rel="external">点这里</a>查看。</p>
<p>之所以这样设计，实际上，可以认为成，当block有了外部变量的捕获，那么它就需要持有这个外部变量，就是赋值到结构体成员上。这种捕获，造成了block对应struct结构体大小的动态变化，所以，在设计上适合放在栈上更合理。</p>
<h3 id="堆block"><a href="#堆block" class="headerlink" title="堆block"></a>堆block</h3><p>在栈block中，说到过，当函数的栈帧的销毁，那么栈block也会被随之清楚。但是我们一般都需要在函数结束后仍然能使用这个block，所以，需要把栈block拷贝到堆上。在copy时，就把栈block的类型转换成了堆block。</p>
<p>所以在MRC时代，block属性的关键字必须是copy。这样就可以保证在给block属性赋值的时候，能把在栈上的block给copy到堆区。</p>
<p>而讲得再细一点，为什么非要把block放到堆区才安全。</p>
<p>因为你可以这么理解，block就是个匿名函数，只不过我们给了一个变量来引用这个匿名函数，在需要的时候调用。但是,<strong>栈block会随着函数栈帧的销毁而销毁，这样一来，我们用之前做引用的变量再去调用这么一块被销毁的内存，就会出现内存崩溃</strong>。</p>
<p>所以，只有把block放到由我们来控制生命周期的堆区中，才能安全地使用block。</p>
<p>我们知道，在OC中，对象都会在堆区存储。实际上，此时的堆block，它的确就是一个对象。而且，你还需要对它手动release。</p>
<p>当然，当ARC时代来临，这就又有所不同了。</p>
<h2 id="ARC下的block"><a href="#ARC下的block" class="headerlink" title="ARC下的block"></a>ARC下的block</h2><p>首先先看我写的一段测试代码：</p>
<p><img src="http://oo6vl10at.bkt.clouddn.com/7BF1237F-0498-475E-94B9-E012D6418D21.png" alt=""></p>
<p>这是在ARC下的Command line tools工程。</p>
<p>这段代码中的<code>str</code>是做常量区地址参考的，最后的<code>obj</code>是做堆区地址参考的。</p>
<p>可以看到<code>str</code>的地址是<code>0x1000021f0</code>，<code>obj</code>的地址是<code>0x100406b40</code>。的确符合预期，常量区地址非常小，堆区地址稍微大一些。</p>
<h4 id="全局block-1"><a href="#全局block-1" class="headerlink" title="全局block"></a>全局block</h4><p>先看<code>gBlock</code>。这个block没有捕获任何外部变量，仅仅是打印一句文字。所以，理所当然，它是一个全局block。通过地址的观察，的确如此，比<code>str</code>常量的地址还小。</p>
<h4 id="堆block和栈block"><a href="#堆block和栈block" class="headerlink" title="堆block和栈block"></a>堆block和栈block</h4><p>再看<code>mBlock</code>。这个block是捕获了一个外部变量，打印一个外部声明的字符串。这种情况下，在MRC小中应该是属于栈block。但是这里的执行结果显示，它实际是一个堆block。</p>
<p>实际上，这是因为在ARC下，对block做了大量处理。现在的情况是，<strong>只要一个block被赋值给一个<code>strong</code>变量，会自动copy。</strong>所以，我们看到<code>mBlock</code>这个地址，和参考对象<code>obj</code>的地址非常接近。</p>
<p>这样一来，实际上在ARC下，很难在写出一个栈block的情况，因为一旦有赋值给<code>strong</code>变量，那么就得到的是堆block。所以，为了写出一个栈block，我使用一个函数，入参是block类型，但是这个block参数没有经过任何一次赋值操作，直接放在了函数参数里。所以，这样就可以再函数体内得到这个栈block类型的参数。</p>
<p>通过地址，可以看到，这个栈block的确地址很大。在给这个栈block进行一次手动copy后，block也变成了堆block。</p>
<p>不过，这里虽然倒弄出来一个栈block，不过这种情况是不会有栈block被提前释放的问题。因为这个栈block作为入参，他的生命周期本身也是跟随这个函数的函数体。函数体栈帧释放，block也被释放，由于函数外并没有对block有引用，所以，这个block也可以被安全的释放。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>网上很多关于block的资料，说使用block会造成崩溃，实际都是因为文章太老。现阶段的block是非常安全的。而且LLVM编译器的检查也十分完善，可以提前发现仅有的一些block被提前释放的情况。</p>
<p><strong>所以，在ARC下，你可以大胆地使用block，而不太需要在意block本身的生命周期。因为他实际和我们平常用的其他NSObject对象的表现，并无二致。</strong></p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://blog.ibireme.com/2013/11/27/objc-block/" target="_blank" rel="external">objc 中的 block</a></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="https://suntao.me/2017/05/18/block到底啥时候崩溃/" data-id="cj2udk7jk0002wxfybfjduoze" class="article-share-link">分享到</a><div class="tags"><a href="/tags/blcok/">blcok</a></div><div class="post-nav"><a href="/2017/04/30/个人对于super的调用过程中，一些不一样的理解/" class="pre">个人对于super的调用过程中，一些不一样的理解</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://suntao.me"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/05/18/block到底啥时候崩溃/">block到底啥时候崩溃</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/30/个人对于super的调用过程中，一些不一样的理解/">个人对于super的调用过程中，一些不一样的理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/19/闲情——C语言指针/">闲情——C语言指针和数组的探索</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/10/iOS 客户端对于运营商劫持的一点点对抗方式/">iOS 客户端对于运营商劫持的一点点对抗方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/24/针尖上带着脚镣跳舞的widget/">针尖上带着脚镣跳舞的widget</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/14/从-property说起（四）深入成员变量/">从@property说起（四）深入成员变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/09/从-property说起（三）atomic与多线程锁/">从@property说起（三）atomic与多线程锁</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/21/从-property说起（二）当我们写下-property-nonatomic-weak-id-obj时，我们究竟写了什么/">从@property说起（二）weak关键字</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/20/从@property说起（一）开题篇/">从@property说起（一）开题篇</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/13/iOS 客户端基于 WebP 图片格式的流量优化（下）/">iOS 客户端基于 WebP 图片格式的流量优化（下）</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C语言/">C语言</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WebP/">WebP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Widget/">Widget</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/block/">block</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/runtime/">runtime</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/从-property说起/">从@property说起</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络/">网络</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/iOS实际应用/" style="font-size: 15px;">iOS实际应用</a> <a href="/tags/blcok/" style="font-size: 15px;">blcok</a> <a href="/tags/防劫持/" style="font-size: 15px;">防劫持</a> <a href="/tags/OC基础/" style="font-size: 15px;">OC基础</a> <a href="/tags/runtime-OC底层/" style="font-size: 15px;">runtime OC底层</a> <a href="/tags/iOS10-Widget/" style="font-size: 15px;">iOS10 Widget</a> <a href="/tags/C指针/" style="font-size: 15px;">C指针</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Me.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.0.47/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>